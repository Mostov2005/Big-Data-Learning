# Статьи про DockerCompose
# https://habr.com/ru/companies/ruvds/articles/450312/
# https://devops.org.ru/dockercompose-summary

# В конфигурационном файле должны быть определены сервисы, сети и тома

# Раздел, в котором будут описаны сервисы, начинается с 'services'.
# 1 сервис = 1 контейнер.
# Сервисом может быть клиент, сервер, сервер баз данных...

services:

  # Начинаем описание сервисов с идентификатора.  Идентификатор
  # сервиса можно задать произвольно.  Здесь для именования сервиса
  # использован идентификатор 'server'.

  server: 

    # Имя образа контейнера, который нужно запустить. При первом
    # выполнении образ будет загружен из репозитория на сайте
    # https://hub.docker.com/. После имени образа, через двоеточия
    # можно указать теги. В частности можно задать требуемую версию.
    # Самая последня стабильная версия задаётся тегом
    # 'latest'. Доступные версии можно посмотреть на сайте
    # репозитория.

    image: nginx:latest 

    # Команда пересборки (модификации) образа. Если базовый образ
    # нужно модифицировать, например установить дополнительные пакеты,
    # создаётся Dockerfile, содержащий соответствующие команды. Путь к
    # этому файлу задаёт команда 'build'. При этом имя базового образа
    # указывается в файле Dockerfile и поэтому команду image задавать
    # не нужно.

    build: ./path_to_dockerfile/

    # Команда инициализации, которую нужно выполнить после создания
    # образа. Создатели образов используют разные механизмы
    # инициализации. Иногда готовят скрипт командной оболочки, иногда,
    # как в примере ниже - программу на питоне.

    command: python run_all.py

    # Если в контейнере запущен сервер и мы хотим обратиться к нему с
    # нашего компьютера (хоста), находясь за пределами контейнера, мы
    # должны организовать перенаправление порта, который слушает
    # сервер внутри контейнера, на порт хоста.  При его использовании
    # применяется следующая конструкция: [порт хоста]:[порт
    # контейнера] В нашем случае нужно использовать порт компьютера
    # 1234 и организовать его связь с портом 4321 контейнера. Номера
    # портов хоста и сервера не обязательно должны быть разными.

    # Обратите внимание на тире перед номерами портов. Это признак
    # того, что значения параметра 'ports' представляет собо списка. Каждый
    # элемент списка начинается с тире. 

    ports:
      - 1234:4321
      - 8080:8080

    # Чтобы хранить данные вне контейнера используются тома, ключевое
    # слово 'volumes'. В простейшем случае том - это каталог на хосте,
    # который монтируется к какому-то каталогу контейнера. Именованный
    # том - это тоже каталог, но созданный докером в системной области
    # (под Linux это /var/lib/docker/volumes/. Наконец есть анонимные
    # тома - это каталоги со случайными именами, созданные в системной
    # области. Анонимные тома создаются когда контейнеру для работы
    # нужно записывать какие-то файлы и для этого в конфигурации не
    # предусмотрены тома явным образом. Именованные тома нужно
    # описывать не внутри секции `services`, а в отдельной секции,
    # которая также называется `volumes`. В общем случае именованные
    # тома могут представлять собой различные типы данных и ресурсы,
    # которые необходимо хранить между запусками контейнеров, избегая
    # их потери при остановке или удалении контейнеров.  При
    # монтировании каталога хоста путь к нему нужно начинать с './' -
    # это значит путь задан по отношению к текущей папке.

    volumes: 
      - ./local_data/nginx.conf:/etc/nginx/nginx.conf # Локальная папка монтируется в контейнер
      - my_data:/home/user # Монтируем именованный том, описанный в секции 'volumes'

    # Ключевое слово 'network_mode' используется для описания типа
    # сети. 
    
    # host: Контейнер использует сетевой стек хост-машины. Это
    # означает, что контейнер будет использовать тот же IP-адрес и
    # порты, что и хост. Это может привести к конфликтам портов и
    # усложнению управления.

    # bridge (по умолчанию): Контейнеры подключаются к виртуальной
    # сети (бриджу), созданной Docker. Они получают IP-адреса из этой
    # сети и могут общаться друг с другом. Внешний мир может общаться
    # с контейнерами через порты, проброшенные на хост-машину.

    # none: Контейнер не имеет сетевого доступа, он полностью
    # изолирован от сети.

    network_mode: host

    # Когда запускаются несколько контейнеров, docker создаёт для них
    # сеть, через которую они могут взаимодействовать. При помощи
    # параметра `networks` можно указать, к каким docker-сетям должен
    # быть подключён данный сервис. После секции сервисов можно
    # создать секцию `networks` в которой описать режим работы
    # используемых сетей.

    networks:
      netw1:
    
    # Параметр restart в docker-compose.yml определяет политику
    # перезапуска контейнеров в случае их остановки или сбоя. Он
    # задается для каждого сервиса в файле docker-compose.yml и может
    # иметь следующие значения:

    # no (по умолчанию): Контейнер не будет перезапускаться
    # автоматически.

    # always: Контейнер будет перезапускаться всегда, даже если он был
    # остановлен командой docker stop. Перезапуск прекратится только
    # если контейнер будет удален с помощью docker rm.
    
    restart: always

    # При помощи ключевого слова `environment` задаются переменные
    # окружения контейнера. Значения переменных можно записывать без
    # кавычек. Обратите внимание на двоеточия после имён
    # переменных. Это значит, что 'environment' - это не отдельный
    # параметр, а раздел, внутри которого каждая переменная задаётся
    # как отдельный параметр.
    
    environment:
      PASSWORD: admin
      USER: admin

      
  # Второй сервис назовём 'client'
  client:

    # Ключевое слово 'depends_on' позволяет указывать, должен ли
    # сервис, прежде чем запуститься, ждать, когда будут готовы к
    # работе другие сервисы.  Нам нужно, чтобы сервис 'client'
    # дождался бы готовности к работе сервиса 'server'.

    depends_on:
      - server


# Секция описания именованных томов      

volumes:
  
  # Идентификатор именованного тома. Обычно достаточно просто указать
  # идентификатор. Но при необходимости можно указать дополнительные
  # настройки, см. документацию

  my_data:


# Секция описания docker-сетей

networks:
  netw1:
